package it.polito.dp2.NFV.sol1;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.GregorianCalendar;
import java.util.Set;
import java.util.List;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.math.BigInteger;

import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

//validation import
import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;

import org.xml.sax.SAXException;

//import the java content classes generated by binding the compiler
import it.polito.dp2.NFV.NfvReader ;
import it.polito.dp2.NFV.NfvReaderException ;
import it.polito.dp2.NFV.NfvReaderFactory;
import it.polito.dp2.NFV.VNFTypeReader;
import it.polito.dp2.NFV.HostReader;
import it.polito.dp2.NFV.NodeReader;
import it.polito.dp2.NFV.LinkReader;
import it.polito.dp2.NFV.NffgReader;
import it.polito.dp2.NFV.sol1.jaxb.*;
import it.polito.dp2.NFV.ConnectionPerformanceReader;


public class NfvInfoSerializer {
	private NfvReader monitor;
	private DateFormat dateFormat;

	
	/**
	 * Default constructor
	 * @throws NfvReaderException 
	 */
	public NfvInfoSerializer() throws NfvReaderException {
		//create the factory 
		NfvReaderFactory factory = NfvReaderFactory.newInstance();
		//create a new instance of the NfvReader implementation
		monitor = factory.newNfvReader();
		dateFormat = new SimpleDateFormat("dd/MM/yyyy hh:mm");
	}
	
	public NfvInfoSerializer(NfvReader monitor) {
		super(); 
		this.monitor = monitor;
		dateFormat = new SimpleDateFormat("dd/MM/yyyy hh:mm");
	}

	public Dp2NfvType getInfo(){  
		Dp2NfvType dp2_nfv = populateDp2_nfv(this.monitor, this.dateFormat);
		return dp2_nfv;
	}
	
	private Dp2NfvType populateDp2_nfv(NfvReader monitor, DateFormat dateFormat){
		Dp2NfvType dp2_nfv = new Dp2NfvType();
		
		//create and populate the sub elements of dp2_nfv: catalog, in and the list of nffgs
		CatalogType catalog = populateCatalog(monitor.getVNFCatalog());
		dp2_nfv.setCatalog(catalog);
		
		
		InType in = populateIn(monitor);
		dp2_nfv.setIn(in);
		
		List<NfFgType> nffg_list = dp2_nfv.getNfFg();
		populateNffgs(monitor.getNffgs(null), nffg_list); 
		//no need to set the nffg_list, because it's a live list
		return dp2_nfv;
	}
	
	private CatalogType populateCatalog(Set<VNFTypeReader> set){
		//create a new catalog
		CatalogType c = new CatalogType();
		//extract the live list we want to populate
		List<VNFTType> ft_list = c.getVNFT(); 
		//for each VNFT type in the Set<VNFTypeReader>
		for (VNFTypeReader vnfType_r: set) {
			//create a VNFT element, populate it and add it to the List<VNFTType>
			VNFTType ft = new VNFTType();
			ft.setDiskStorage(vnfType_r.getRequiredStorage());
			ft.setMemory(Integer.valueOf(vnfType_r.getRequiredMemory()));
			ft.setName(vnfType_r.getName());
			ft.setFuncType(FuncTypeType.fromValue(vnfType_r.getFunctionalType().value()));
			ft_list.add(ft);
		}
		return c;
	}

	private InType populateIn(NfvReader monitor){
		Set<HostReader> set =monitor.getHosts();
		//create an InType element
		InType in = new InType();
		//extract the live list we want to populate
		List<HostType> host_r = in.getHost();
		//for each element in the Set<HostReader>
		for(HostReader h: set){
			//create a Host element, populate it and add it to the List<HostType> 
			HostType host = new HostType();
			host.setName(h.getName());
			host.setDiskStorage(h.getAvailableStorage());
			host.setMemory(h.getAvailableMemory());
			host.setMaxVnf(BigInteger.valueOf(h.getMaxVNFs()));
			
			//inside Host there is also a list of nodes that contains references (string) to the nodes
			Set<NodeReader> nodeSet = h.getNodes();
			List<String> node = host.getNode();
			for (NodeReader nr: nodeSet){
				node.add(nr.getName());
			}
			host_r.add(host);
		}
		//for each pair of added host, there is a connection
		List<ConnectionType> connections = in.getConnection();
		for(HostReader h1:set){
			for(HostReader h2: set){
				ConnectionPerformanceReader cpf = monitor.getConnectionPerformance(h1, h2);
				//create a connection, populate it and add it to the List<ConnectionType>
				ConnectionType conn= new ConnectionType();
				conn.setAvgThrough(cpf.getThroughput());
				conn.setAvgLatency(cpf.getLatency());
				conn.setHost1(h1.getName()); 
				conn.setHost2(h2.getName());
				connections.add(conn);
			}
		}
		return in;
	}
	
	private void populateNffgs(Set<NffgReader> set, List<NfFgType> nffgs){	
		//populate each nffg in the nffgs list
		for (NffgReader nffg_r: set){
			NfFgType nffg = new NfFgType();
			nffg.setName(nffg_r.getName());
			//set deploy time
			XMLGregorianCalendar xmlgc;
			try {
				xmlgc = DatatypeFactory.newInstance().newXMLGregorianCalendar((GregorianCalendar)nffg_r.getDeployTime());
				nffg.setDeployTime(xmlgc);
			} catch (DatatypeConfigurationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			//set the nodes belonging to the nffg
			Set<NodeReader> nodeSet = nffg_r.getNodes();
			List<NodeType> nodes = nffg.getNode();
			for (NodeReader nr: nodeSet) {
				NodeType node = new NodeType();
				node.setName(nr.getName());
				node.setVNFT(nr.getFuncType().getName());
				node.setHost(nr.getHost().getName());
				node.setNffgName(nffg.getName());
				//each node ad also a list of Link that needs to be populated
				List<LinkType> links = node.getLink();
				Set<LinkReader> linkSet = nr.getLinks();
				for (LinkReader lr: linkSet){
					LinkType link = new LinkType();
					link.setDestNode(lr.getDestinationNode().getName());
					link.setSourceNode(lr.getSourceNode().getName());
					link.setName(lr.getName());
					link.setMinThrough(lr.getThroughput());
					link.setMaxLatency(lr.getLatency());
					links.add(link);				
				}
				nodes.add(node);
			}	
		nffgs.add(nffg);
		}
	}

	
	/**
	 * @param args
	 */
	
	public static void main(String[] args) {
		//check that the number of parameters is correct
		if(args.length<1){
			System.out.println("correct usage: <program> <output file name>");
		}
		
		//create a new NfvInfoSerializer
		NfvInfoSerializer wf;	
		
		//validation against the XML schema developed in the Assignment 1a
		SchemaFactory sf = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);
		
		//serialize the obtained JAXBElement
		try {
			//create an Output stream on which print the info
			FileOutputStream out = new FileOutputStream(args[0]);
			wf = new NfvInfoSerializer();
			Dp2NfvType dp2_nfv= wf.getInfo();
			
			//create a JAXB context
			JAXBContext jc = JAXBContext.newInstance("it.polito.dp2.NFV.sol1.jaxb"); 
			
			//create an element for marshal. the JAXBElement is the root element 
			JAXBElement<Dp2NfvType> root_elem = (new ObjectFactory()).createDp2Nfv(dp2_nfv);
	        // create a Marshaller and marshal to System.out
			Marshaller m = jc.createMarshaller();
			
			//set the validation schema
			Schema schema = sf.newSchema(new File("xsd/nfvInfo.xsd"));
			m.setSchema(schema);
			
			m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
	        m.marshal(root_elem,out);
	        
	        
		
		} catch (JAXBException e) {
			e.printStackTrace();
			System.exit(1);
		}
		catch (NfvReaderException e) {
			System.err.println("Could not instantiate data generator.");
			e.printStackTrace();
			System.exit(1);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.exit(1);
		} catch (SAXException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.exit(1);
		}
		
	}

}

